---
title: ParamSpec
seoTitle: How to Annotate @decorators with ParamSpec
summary: How to Annotate @decorators with ParamSpec
isReleased: true
isSequel: false
lastModDate: 2020-07-09T09:15:00-0401
firstModDate: 2020-07-09T09:15:00-0401
minutesToRead: 2
tags:
  - 'python'
  - 'typing'
  - 'paramspec'
---

<C>
<L href="https://peps.python.org/pep-0612/">PEP 612</L> introduced `ParamSpec`, which you might’ve encountered before. Here’s a quick refresher on how to use `ParamSpec` for typing decorators. This won’t be a deep dive, it’s all in the official docs already. Let’s jump straight to the point with a simple decorator.
</C>

<Code
  code={`from functools import wraps 

def decorator(f):
    @wraps(f)
    def wrap(*args, **kwargs):
        return f(*args, **kwargs)
    return wrap

@decorator
def foo(*args, **kwargs):
    ...
`}
  language="python"
  showLineNumbers={true}
/>

<C>
How would you type that?
</C>

<Code
  code={`from typing import Callable, Any
from functools import wraps 

def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
    @wraps(f)
    def wrap(*args: Any, **kwargs: Any) -> Any:
        return f(*args, **kwargs)
    return wrap
`}
  language="python"
  showLineNumbers={true}
/>

<C>
Here’s the problem: this approach is overly broad. It allows *anything* for `args`, `kwargs`, and the return type, which makes it confusing and hard to maintain. Let’s clean this up using `ParamSpec`.
</C>

<H2>Using ParamSpec</H2>

<C>
We’ll use a generic `_T` for the return type and `_PSpec` to capture the structure of `args` and `kwargs`. This way, we precisely type both the inputs and output of the function `f`.
</C>

<Code
  code={`from typing import ParamSpec, TypeVar, Callable
from functools import wraps 

_T = TypeVar("_T")
_PSpec = ParamSpec("_PSpec")

def decorator(f: Callable[_PSpec, _T]) -> Callable[_PSpec, _T]:
    @wraps(f)
    def wrap(*args: _PSpec.args, **kwargs: _PSpec.kwargs) -> _T:
        return f(*args, **kwargs)
    return wrap

@decorator
def foo(*args, **kwargs):
    ...
`}
  language="python"
  showLineNumbers={true}
/>

<H2>What About Specific Parameters?</H2>

<C>
Let’s say `foo` isn’t generic and takes a specific parameter like `bar`. For example:
</C>

<Code
  code={`class Bar:
    ...
    
@decorator
def foo(bar: Bar, /, *args: bool, **kwargs: str) -> None:
    pass
`}
  language="python"
  showLineNumbers={false}
/>

<C>
Here, you need to use `Concatenate` to combine the known parameter type (`Bar`) with the rest of the `args` and `kwargs`. The function signature becomes:
</C>

<Code
  code={`f: Callable[Concatenate[Bar, _PSpec], _T]
`}
  language="python"
  showLineNumbers={false}
/>

<C>
So the decorator function becomes:
</C>

<Code
  code={`from typing import Concatenate

def decorator(f: Callable[Concatenate[Bar, _PSpec], _T]) -> Callable[_PSpec, _T]:
    @wraps(f)
    def wrap(*args: _PSpec.args, **kwargs: _PSpec.kwargs) -> _T:
        return f(Bar(), *args, **kwargs)
    return wrap
`}
  language="python"
  showLineNumbers={false}
/>

<C>
Between the wrapper and the return statement, you can perform additional actions like logging, sending metrics, or anything else. Now, what if your function needs even more parameters? Just add them inside `Concatenate`.
</C>

<H2>Handling Multiple Parameters</H2>

<Code
  code={`from typing import Concatenate

class X:
    ...

def decorator(f: Callable[Concatenate[X, Bar, _PSpec], _T]) -> Callable[_PSpec, _T]:
    @wraps(f)
    def wrap(*args: _PSpec.args, **kwargs: _PSpec.kwargs) -> _T:
        x = X()
        bar = Bar()
        print(f'here is x: {x}')
        return f(x, bar, *args, **kwargs)
    return wrap
`}
  language="python"
  showLineNumbers={false}
/>

<C>
Now `f` looks like this:
</C>

<Code
  id="IntersectionObserver"
  code={`@decorator
def foo(x: X, bar: Bar, /, *args: bool, **kwargs: str) -> None:
    pass
`}
  language="python"
  showLineNumbers={false}
/>

<C>
You can call it like this:
</C>

<Code
  code={`foo(X(), Bar(), True, kwarg1='...')
`}
  language="python"
  showLineNumbers={false}
/>

<C>
By using `ParamSpec` and `Concatenate`, you can create well-typed decorators that are flexible yet precise. It’s cleaner, more robust, and saves you from the ambiguity of `Any`.
</C>
