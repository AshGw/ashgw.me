---
title:  Fundamentals
seoTitle: The root cause of developer skill-issues ?
summary: Not asking why is the root cause of developer skill-issues
isReleased: true
isSequel: false
lastModDate: 2024-04-01T09:15:00-0401
firstModDate: 2024-04-01T09:15:00-0401
minutesToRead: 10 
tags:
  - 'rants'
  - 'scams'
  - 'skill-issues'

---

<C>
This blog post was inspired by a recent conversation with a friend who had completed yet another ripoff JavaScript bootcamp. When they asked me whether they should start with 
<L href="https://spring.io/projects/spring-boot">Spring</L>, <L href="https://www.djangoproject.com/">Django</L>, or <L href="https://expressjs.com/">Express</L>, I got confused. The question seemed misguided, I first thought about redirecting their focus towards a foundational understanding of <L href="https://datatracker.ietf.org/doc/html/rfc2616">HTTP</L> and grasp the protocol's essence first. But then I soon realized the broader issue at hand, which is the misconception that learning involves a linear progression of hopping from one tool to another, across different languages and ecosystems.
<S/>
It became apparent that my friend's inquiry about different frameworks operating on totally different languages and ecosystems, neither of which they were even proficient in, reflected a common misunderstanding. 
My advice was: focus on learning more fundamentals. Better yet, grasp how computers operate. So I ended up sending them a copy of "The C Programming Language" book and advised them to start there. Reflecting on this, I realized my advice was somewhat selfish, as I didn't want to lecture for 30 minutes about the importance of fundamentals and where to even begin.
</C>



<H2>Here's what I should've replied with</H2>
<C>
Software development is primarily about problem-solving, just like mathematics.
</C>


<C>
In math, attempting to solve complex equations without a solid grasp of fundamental principles by relying solely on memorization, you're trying to piece together a puzzle without a clear understanding of how the pieces fit. Without a foundation to connect concepts, Your brain neurons struggle to connect and make sense of scattered information, leading to frustration, boredom, thus imminent failure.
</C>

<S2/>

<C>
Before one attempts to solve integrals and differential equations, they must assess their current knowledge level first. If they know absolutely nothing about math, they must start with basic arithmetic and go from there.
</C>

<S/>

<C>
The question is, how do I learn or where do I even look ? The answer is simple: we live in the internet era, all information is free (even paid ones) so start learning how to look for shit on your own, you don't need to get pampered!
</C>


<H2>Stop Getting Duped By Dream Sellers</H2>
<C>
Stop falling prey to the false promises peddled by individuals and institutions eager to take your money by selling you unrealistic dreams. Just as you can't expect to achieve six-pack abs and bulging biceps in four weeks with a magical training program advertised by some juiced up guy on Instagram when you haven't stepped in the gym for a day in your life, you shouldn't expect to become a "full-stack" developer in 3 months through bootcamps.
</C>
<C>
So let me say this: Connecting some JavaScript CRUD APIs together does not make you a "full-stack" developer, no one on earth is full stack, you cannot be at all places at once, you cannot be an expert at literally everything at once **ESPECIALLY AFTER 3 MONTHS!**
</C>
<C>
 Let me reiterate: connecting some JavaScript CRUD APIs together does not make you a full-stack developer, it only means you've memorized some broken English to create another useless todo app (at least be creative). These advertised programs always **overpromise** and **underdeliver**, setting unrealistic expectations and leaving many aspiring developers disillusioned and frustrated and definitely not ready to deliver in the market, well a marked that is drowning in <L href="/blog/tag/skill-issues">mediocre</L> talent anyway. 
</C>

<C>
Take the time to critically assess your goals and the feasibility of achieving them within a reasonable timeframe, rather than succumbing to flashy marketing tactics promising quick and effortless success.
</C>

<C>
When you focus on mastering the core concepts, you're building a strong foundation. This foundation allows you to adapt to new technologies and frameworks **RAPIDLY** with **EASE** because you comprehend the fundamental principles upon which they're constructed. 
</C>
<C>
It's the same as driving. Sure, you can learn to drive in a couple of weeks and pass the exam, but true proficiency goes beyond memorizing the sequence of which 3D objects have to move in a 3D plane in order to make a vehicle take you from point A to point B.
</C>
<C>
What I mean by that is, sure, you can learn React in 3 months too, but did you learn it? or memorize it? Did you learn programming or have memorized some language specific APIs? In my opinion before you can use a tool, you should be able to build a prototype of it, understand how it works under the hood. Trying to use React? Build a rudimentary version of it. Trying to use an <L href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</L>? Build one. What about trying to use the new trending web framework which literally does the same thing all the other ones do? Build it. Blast some raw <L href="https://datatracker.ietf.org/doc/html/rfc9293">TCP</L> until you have something.
All I'm trying to say is that technologies come and go, your favorite blazingly fast, easy to implement, easy to learn framework comes and goes, it's literally an implementation of the same <L href="https://en.wikipedia.org/wiki/Request_for_Comments">RFC</L> made with different programming languages. You don't have to know such and such library to be an expert, that thing is ephemeral, if it disappears or goes out of fashion, there goes you expertise with it, congrats! you've wasted your time.
</C>
<C>
Understand that true engineering means going beyond memorization and instead comprehending the fundamental principles that govern a system. It's about understanding the "why" behind things, which in turn makes you more versatile and effective problem solver.
</C>
<C>
When you start asking "why", you'll gradually connect the pieces together, starting from <L href="https://youtu.be/SLFN-XfeYXw?si=0IDKskPOzAsI6EIe">bottom</L> and working your way up to abstractions **NOT THE OPPOSITE!** Even creating them yourself. Eventually, you'll have the full picture.
</C>
<H2>I Get It, But What Should I learn ?</H2>
<C>
I can't precisely outline a <L href="https://roadmap.sh">roadmap</L> for you because the field is vast. If I lay out a plan, you might quickly lose interest, feeling overwhelmed by its enormity, you might even focus more on unnecessary topics while leaving more important ones without much attention, because all of these concepts I'll be mentioning will sound like a foreign language to you. Instead, I'll suggest an approach:
</C>
<C>
 Just pick a thing, complex or simple, anywhere that you think might be interesting, then keep asking why does this thing exist? What problem is it trying to solve? and follow the trail. By doing so, you'll find yourself going deep into the <L href="https://youtu.be/zE7PKRjrid4?si=24T8DoioD-7WotOC&t=93">rabbit hole</L>. It is an intricate journey, but after such a deep dive, you'll find yourself surpassing 99% of individuals out there who don't ask questions and don't even put in any effort at all, just accepting the information as is, and that goes out for everything not just software engineering.
</C>
<H2>Here Are Some Tips</H2> 
<C>
To save you some extra time your journey as a new comer: 
</C>
<C>
You can consider leveraging the established paths laid out by reputable educational institutions not <L href="/blog/shitty-colleges">shitty ones.</L> Start with the foundational courses, the topics of the Harvard CS major is great way to start. Speedrun through these topics, not all of them, many are just filler courses (universities have to make money too), lookup which ones are which, don't get too deep, you won't use most of them (practically), but they're very valuable to know.
</C>

<C>
Pick one programming language and stick to it. Don't hop between languages at this stage. Once you have attained proficiency (meaning you can build almost anything with it), explore other languages and paradigms while adhering strictly to their inherent principles and guidelines. It's crucial to refrain from blending different paradigms together, you'll get good at that language once you explore how other languages solve the same problem differently, give each of these paradigms their time. Do not hop too fast between them, also you don't need to master them all, no, just enough to build some quality software with them and attain that **shift in thinking** which is what you're trying to do, not writing 17 different languages in your resume, that only means you're <L href="https://www.urbandictionary.com/define.php?term=mid">mid</L> in 17 different languages. Congats! Again.
</C>
<C>
Study code from successful projects like the ones with many starts on GitHub. By analyzing professional code (well, let's suppose it's professional, you won't notice now) written in the languages you're learning, you'll discern patterns, anti-patterns, design principles, best practices and more.
</C>
<C>
Build meaningful and **creative** projects, no trivial "todo" apps, **I swear If I catch someone creating another todo app, it's up!** 
</C>
<C>
Draw inspiration from the code you read and aim for projects that challenge and actually engage you, put genuine effort into them. Each project should be unique to maximize your learning, if your brain is not thinking as hard as tough game of chess or poker, you're wasting time and lying to yourself;
</C>

<C>
Always consult official documentations and RFCs when learning a new technology, language, or anything in life really. Like the topic of health, read the official studies instead of relying on some guy on social media <L href="https://www.urbandictionary.com/define.php?term=Yapping">yapping</L> about "studies show that...". **WHAT STUDIES? LEMME SEE THEM!**
<S/>
If the documentation is inadequate, resort to reading the source code and try to connect the dots. Never rely on secondhand information. Your brain may trick you into seeking the easiest path to preserve the most amount of energy, like watching a video or purchasing courses (though the vast majority are a ripoff, some can be time-savers). Distilled secondhand information can lead astray, not even mentioning mis/disinformation.
<S/> 
Instead, your brain should engage, think, and exert effort to understand, if it's dormant you're slacking big time.
</C>
<C>
Start using Linux instead of you normie operating system, you can search <L href="https://duckduckgo.com/?va=i&t=hd&q=man+windows+is+shit&ia=web">why</L>.
</C>
<C>
Be an engineer not a <L href="https://johndanielraines.medium.com/be-an-engineer-not-a-frameworker-c58fe28d0c88">frameworker</L>, so think like one.
</C>

<H2>Conclusion</H2>
<C>
Unfortunately, education that's most marketed out here often falls short of its ideal purpose. It tends to prioritize surface-level familiarity with an array of tools and technologiesâ€”many of which are ephemeral, destined to fade into obsolescence within a few short years, just to make a quick buck off of people that lack guidance. Genuine mastery, however, requires transcending the superficial and understanding the fundamental principles that underpin the field. Rather than merely focusing on the latest frameworks and trends, you should strive to grasp how technologies truly function and question the abstractions provided by these different tools.
As you dive deeper into the journey, with time, you'll inevitably begin to question the validity of certain concepts you've came across along the way. When you find yourself forming your own opinions and insights, it's a sign that you're quite advanced in your mastery of the craft.
</C>





