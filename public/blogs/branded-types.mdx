---
title: Branded Types
seoTitle: Write Safer TypeScript with Branded Types
summary:  Write safer TypeScript with branded types
isReleased: true
isSequel: false
lastModDate: 2024-04-27T09:15:00-0401
firstModDate: 2024-04-27T09:15:00-0401
minutesToRead: 3
tags:
  - 'typescript'
  - 'typing'
---

<C>
Not all TypeScript code is created equal. Some of it’s fine, but a lot of it? Let’s just say “type safety” is more of a suggestion than a rule. If you want to actually write **safe**, **robust**, and **bug-resistant** TypeScript, you need to step it up. One way to do that is by using a pattern called **Branded Types** (also known as Nominal Types, Unique Types, or New Types). Different names, same goal: giving your types the specificity they deserve instead of leaving your code to guesswork.
</C>

<H2>The Problem</H2>

<C>
Here’s a simple question for you: how many things can go wrong in this code?
</C>

<Code
  code={`function requestBaz(barID: string, fooID: string) {
  if (
    fooID.concat().toLowerCase() === 'fooid' &&
    barID.concat().toLowerCase() === 'barid'
  ) {
    return 'baz';
  }
}

type Foo = {
  id: string;
  foo: string;
};

type Bar = {
  id: string;
  bar: string;
};

// ...

const baz = requestBaz(foo.id, bar.id);
const baz2 = requestBaz(bar.id, foo.id);
`}
  language="tsx"
  showLineNumbers={true}
/>

<C>
What does `requestBaz()` actually return? Is it a string? If so, can **any string** work? Or only some? Let’s talk about the real issue here: `fooID` and `barID` are both plain strings. Mix them up, like this:
</C>

<Code
  code={`const baz = requestBaz(foo.id, bar.id);
const baz2 = requestBaz(bar.id, foo.id);
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
This code runs. No errors. But the logic is broken, and the bug goes undetected. Multiply this by hundreds of lines in a real-world codebase, and you’ve got a disaster brewing. So, how do you fix this? Enter Branded Types.
</C>

<H2>The Solution</H2>

<C>
With Branded Types, we create unique types for `FooID` and `BarID`. They’re both strings under the hood, but they’re not interchangeable anymore. Here’s how you define them:
</C>

<Code
  code={`type FooID = NewType<'FooID', string>;
type BarID = NewType<'BarID', string>;
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
**Note:** The “branding” here needs to be unique, or the type checker won’t flag violations. If you do this:
</C>

<Code
  code={`type FooID = NewType<'BarID', string>;
type BarID = NewType<'BarID', string>;
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
The linter won’t help. Even though the type names (`FooID` and `BarID`) are different, they’re both internally just `BarID`. **Congratulations, you’re back to square one.** Now let’s put these types to use.
</C>

<Code
  code={`type Foo = {
  id: FooID;
  foo: string;
};

type Bar = {
  id: BarID;
  bar: string;
};
`}
  language="tsx"
  showLineNumbers={false}
/>

<H2>How to Create a NewType</H2>

<C>
Here’s the type definition for `NewType`:
</C>

<Code
  code={`declare const __s: unique symbol;
export type NewType<N, T> = T & {
  /**
   * Property \`__s\` is not intended for direct access nor modification.
   * @internal
   */ [__s]: N;
};
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
Now let’s talk about the return type of `requestBaz()`. Sure, it returns a string, but does **any** string work? No. It’s a specific kind of string, a `Baz`. So let’s create a branded type for it:
</C>

<Code
  code={`type Baz = NewType<'Baz', string>;
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
Also, `requestBaz()` might not find a `Baz`. Should it error out? Or fail safe? I think failing safe is better. Let’s create an optional type that explicitly returns `Baz` if found, or `null` if not:
</C>

<Code
  code={`type Optional<T> = T | null;
`}
  language="tsx"
  showLineNumbers={false}
/>

<C>
Here’s the same function, now bulletproof:
</C>

<Code
  code={`import type { NewType, Optional } from 'ts-roids';

type FooID = NewType<'FooID', string>;
type BarID = NewType<'BarID', string>;

type Foo = {
  id: FooID;
  foo: string;
};

type Bar = {
  id: BarID;
  bar: string;
};

type Baz = NewType<'Baz', string>;

function requestBaz(barID: BarID, fooID: FooID): Optional<Baz> {
  // String methods work for fooID and barID, since they're both strings.
  if (
    fooID.concat().toLowerCase() === 'fooid' &&
    barID.concat().toLowerCase() === 'barid'
  ) {
    return 'baz' as Baz; 
  }
  return null; // Explicitly return null.
}

const foo = {} as Foo;
const bar = {} as Bar;

// The line below works perfectly.
const baz1 = requestBaz(bar.id, foo.id); 

// This will fail with a clear type error.
const baz2 = requestBaz(foo.id, bar.id); 
/* TypeError: 
   Argument of type 'FooID' is not assignable to parameter of type 'BarID'.
   Type 'FooID' is not assignable to type '"BarID"'. 
 */
`}
  language="tsx"
  showLineNumbers={true}
/>

<C>
By the way, the `ts-roids` library I created includes a `NewType` utility and more than 120+ type-safe utilities to bulletproof your TypeScript code. Check it out <L href="https://github.com/ashgw/ts-roids">here</L>.
</C>
