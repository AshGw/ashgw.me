---
title: Unit Tests
seoTitle: No one likes leg day, but you should never skip it
summary: No one likes leg day, but you should never skip it
isReleased: true
isSequel: false
lastModDate: 2021-12-14T09:15:00-0401
firstModDate: 2021-12-14T09:15:00-0401
minutesToRead: 3
tags:
  - 'testing'
  - 'quality'
---

<C>
Let’s talk about **unit tests.** Love them or hate them, they’re the bedrock of any respectable codebase. Sure, they can feel like a pain in the ass, time consuming, tedious, and sometimes downright annoying. But if you think skipping them is a good idea, you’re setting yourself (and your team) up for a world of hurt.
</C>
<C>
Unit tests aren’t written to merely catch bugs. They’re your safety net and your **living documentation**. Write them well, and they’ll save you in the long run when you need to refactor, expand, or fix something two years down the line. Write them poorly, or worse, skip them, and your future self will hate you (and anyone that touches that code after you).
</C>

<H2 id='coverage'>100% Code Coverage ≠ Zero Bugs</H2>
<C>
Let me start with this myth: **100% code coverage means bug-free software.** Wrong. Dead wrong. Just because your tests touch every line of code doesn’t mean they’re testing what matters. You could have 100% coverage and still miss critical edge cases.
</C>
<C>
On the flip side, aiming for **50% coverage** is setting the bar so low you’re practically inviting chaos into your codebase. Don’t be that team. There’s no magical number to hit, but **80% is a solid target.** 
</C>
<C>
Now, if your team somehow has 100% coverage, congrats. Either you’ve achieved unicorn-level composable code (very rare) or you’re padding numbers to impress clueless managers (much more common). **Numbers can lie.** Don’t let metrics fool you into thinking your tests are good. Focus on **quality, not quantity.**
</C>

<H2 id='no-preconceptions'>Don’t Assume You Know Everything</H2>
<C>
Here’s another trap: assuming certain values or scenarios are “impossible.” Trust me, the moment you assume “this will never happen,” it absolutely will. Test every code path. Cover the unexpected. Your future self will thank you when the unthinkable happens.
</C>

<H2 id='over-asserting'>Over-Asserting? Break That Shit Down</H2>
<C>
Ever seen a test with a dozen assertions crammed into one function? That’s over-asserting, and it’s a recipe for disaster. When one thing breaks, the whole test becomes a mess to debug. 
</C>
<C>
**Rule of thumb:** one scenario, one test. Focus on what matters for that specific case. Keep it lean, and your tests will be easier to maintain and understand.
</C>

<H2 id='reusable-setup'>Don't Copy Paste And Call It A Day</H2>
<C>
If your test setup looks like a repetitive copy-paste nightmare, you’re doing it wrong. Clean that up. Use **builders** or helper functions to create reusable test scenarios. Your code will be cleaner, your tests more readable, and your teammates less likely to curse your name.
</C>

<H2 id='naming'>Name Your Tests Like a Pro</H2>
<C>
Good test names are **essential**. When your project grows to hundreds of files, clear, descriptive names will save your team from duplicate tests and endless confusion.
</C>
<C>
#### Example: In JavaScript/TypeScript
</C>

<Code
  code={`describe("User Authentication", () => {
  test("should return a token for valid credentials", () => {
    // Test logic
  });
});`}
  language="typescript"
  showLineNumbers={false}
/>

<C>
#### Example: In Python
</C>

<Code
  code={`def test_given_correct_password_then_authentication_succeeds():
    # Test logic here

def test_given_invalid_password_then_authentication_fails():
    # Test logic here`}
  language="python"
  showLineNumbers={false}
/>

<C>
**Avoid this garbage:**
</C>

<Code
  code={`def test_auth1():
    # No one knows what this is
def test_auth2():
    # Or this`}
  language="python"
  showLineNumbers={false}
/>

<H2 id='final-thoughts'>Unit Tests Are a Pain, But They’re Worth It</H2>
<C>
Look, I’m not saying unit tests are fun. They’re not. But they’re needed. They save time in the long run, prevent nightmares, and give you confidence to refactor without breaking everything. Think about construction workers. Sure, they could work faster without safety gear, no harnesses, no nets, just raw speed. But if they fuck up? Someone falls, someone dies, and suddenly the faster timeline doesn’t mean shit because now you’ve got a disaster to clean up instead of a finished project. Unit tests are your safety gear. They slow you down a little upfront, but they make damn sure you’re not scrambling to clean up a catastrophe later.

Now, startups? They love skipping this part. It’s all ‘move fast, break things’ until you actually break something important, and suddenly it’s all-hands-on-deck fixing a bug that messed prod. And guess what? By the time they’re biting it, the team’s already grown. Now you’ve got new engineers staring at spaghetti code with no guardrails, no tests, no confidence that a single line change won’t nuke the whole app. That’s how you get weeks of firefighting instead of building actual features.

You want to skip unit tests? Fine. Just don’t start bitching when your future self, with a bigger team and bigger problems, wants to punch you in the face for being lazy.
</C>

